#! /bin/bash

syncURL="http://sync:2379/v2/keys"
peersURL="${syncURL}/peers"
mappingURL="${syncURL}/mapping"
peerID="${WAVELET_NODE_ID}"

function getKey() {
	local id keys

	id="$1"

	if [ -z "${id}" ]; then
		id=$["${WAVELET_NODE_ID}" - 1]
	fi

	keys="$(echo "${WAVELET_KEYS}" | cut -f $["${id}" + 1] -d ,)"
	if [ -z "${keys}" ]; then
		keys="$(awk -v id="${id}" '($1 == id) { print $2, $3; exit }' </opt/perlin/etc/wallets)"
	fi

	echo "${keys}"
}

function getPrivateKey() {
	getKey "$@" | awk '{ print $1 }'
}

function getPublicKey() {
	getKey "$@" | awk '{ print $2 }'
}

function getLocalIP() {
	getent hosts "$(uname -n)" | awk '{ print $1 }'
}

function registerPeer() {
	local ip port

	ip="$(getLocalIP)"
	port="$1"

	curl -SsL "${peersURL}/${peerID}" \
		-X PUT \
		--data value="${ip}:${port}" \
		--data ttl=30 >/dev/null 2>/dev/null
}

function maintainPeerRegistry() {
	local port
	port="$1"

	(
		while true; do
			registerPeer "${port}"
			sleep 10
		done

	) &
}

function getPeers() {
	local peerIDs
	local peer

	if [ "${WAVELET_NO_RPC}" = 'true' ]; then
		curl -SsL "${peersURL}" 2>/dev/null | \
			jq -crM '.node.nodes[] | select(.key | contains("/peers/'"${peerID}"'") | not) | .value' 2>/dev/null | \
			sort -u | \
			grep -v '^null$'
	else
		peerIDs=( $(curl -sSL "${peersURL}" 2>/dev/null | jq -crM '.node.nodes[].key' | sed 's@^.*/@@') )
		for peer in "${peerIDs[@]}"; do
			if [ "${peer}" = "${peerID}" ]; then
				continue
			fi

			getExternalMappingData "${peer}" | cut -f 1-2 -d / | sed 's@/@:@g'
		done | sort -u
	fi
}

function cacheExternalMappingData() {
	local data
	while true; do
		data="$(curl -sSL "${mappingURL}" 2>/dev/null | jq -crM '.node')"
		if [ "${data}" = 'null' ]; then
			data=''
		fi

		if [ -n "${data}" ]; then
			externalMappingDataCache="${data}"
			break
		fi

		sleep 0.5
	done
}

function uncacheExternalMappingData() {
	unset externalMappingDataCache
}

function getExternalMappingData() {
	local peer
	local data

	peer="$1"
	if [ -z "${peer}" ]; then
		peer="${peerID}"
	fi

	cacheExternalMappingData

	data="$(echo "${externalMappingDataCache}" | jq -crM '.nodes[] | select (.key == "/mapping/'"${peer}"'") | .value')"

	echo "${data}"

	return 0
}

function getExternalPort() {
	local port

	if [ "${WAVELET_NO_RPC}" = 'true' ]; then
		port=$[3000 + $peerID - 1]
	else
		cacheExternalMappingData

		port="$(getExternalMappingData | cut -f 2 -d /)"
	fi

	if [ -z "${port}" ]; then
		return 1
	fi

	echo "${port}"
}

function getExternalIP() {
	local addr

	if [ "${WAVELET_NO_RPC}" = 'true' ]; then
		addr="$(getLocalIP)"
	else
		cacheExternalMappingData

		addr="$(getExternalMappingData | cut -f 1 -d /)"
	fi

	if [ -z "${addr}" ]; then
		return 1
	fi

	echo "${addr}"
}

function setPeers() {
	local try
	local maxTries

	maxTries=$[30 + (${WAVELET_NODE_ID} * 2) + $[RANDOM % 50]]

	for ((try = 0; try < maxTries; try++)) {
		peers=( $(getPeers) )
		if [ "${#peers[@]}" != '0' ]; then
			break
		fi
		sleep 1
	}
}

function waveletDBBackup() {
	(
		backupDir='/db/.backups'
		backupFile="${backupDir}/backup-$(date +%Y-%m-%d-%H-%M.tar.gz)"
		set -e
		mkdir -p "${backupDir}"

		cd /db

		if [ "$(echo *)" = '*' ]; then
			return
		fi

		tar -cf - * | gzip -9c > "${backupFile}"

		cd "${backupDir}"
		find . -name 'backup-*.tar.gz' -mtime +2 -delete
	)
}

function runWavelet() {
	local port
	local argNextArg
	local needPort

	port="$(getExternalPort)"
	nextArg=''
	needPort='true'
	for arg in "$@"; do
		if [ -n "${nextArg}" ]; then
			eval "${nextArg}"'=$arg'
			nextArg=''
		fi
		case "${arg}" in
			--port)
				nextArg='port'
				needPort='false'
				;;
		esac
	done

	if [ "${needPort}" = 'true' ]; then
		set -- "$@" --port "${port}"
	fi

	maintainPeerRegistry "${port}"

	if [ -z "${WAVELET_MEMORY_MAX}" ] || [ "${WAVELET_MEMORY_MAX}" = '0' ]; then
		unset WAVELET_MEMORY_MAX
	fi

	if [ -z "${WAVELET_WALLET}" ]; then
		WAVELET_WALLET="$(getPrivateKey)"
	fi

	if [ -z "${WAVELET_GENESIS}" ]; then
		for ((idx = 0; idx < ${WAVELET_RICH_WALLETS}; idx++)) {
			WAVELET_GENESIS="${WAVELET_GENESIS},"'"'"$(getPublicKey "${idx}")"'": {"balance": 10000000000000000000, "rewards": 5000000}'
		}
		WAVELET_GENESIS="{${WAVELET_GENESIS:1}}"
	fi
	export WAVELET_WALLET WAVELET_GENESIS

	set | grep '^WAVELET' > /tmp/environment.txt

	# XXX:TODO: Currently if any peers specified on the
	# command-line are down, consensus breaks.  So we
	# monitor that set and if it changes, restart Wavelet
	setPeers
	while true; do
		sleep $[30 + ($RANDOM % 30)]

		oldPeers=("${peers[@]}")
		setPeers

		if [ "${peers[*]}" != "${oldPeers[*]}" ]; then
			echo "PEERS DIFFER:" >&2
			echo "  OLD: ${oldPeers[*]}" >&2
			echo "  NEW: ${peers[*]}" >&2
			pkill wavelet
		fi
	done &

	if [ "${WAVELET_BACKUP_DB}" = 'true' ]; then
		while true; do
			waveletDBBackup
			sleep $[60 * 30]
		done &
	fi

	# Run the wavelet process in a loop so that exiting just
	# causes it to reload, unless a special marker file
	# exists
	retval='1'
	while true; do
		if [ -f /tmp/wavelet.exit ]; then
			break
		fi

		/wavelet --host "$(getExternalIP)" "$@" "${peers[@]}"
		retval="$?"

		setPeers

		sleep 0.1
	done
	exit "${retval}"
}

function runBenchmark() {
	exec /benchmark "$@" --wallet "$(getPrivateKey)"

	exit 1
}

# Start the appropriate tool
## Default to bash if no tool is specified
if [ "$#" = '0' ]; then
	set -- bash
fi

mode="$1"
shift

case "${mode}" in
	wavelet)
		runWavelet "$@"
		;;
	benchmark)
		runBenchmark "$@"
		;;
	*)
		# Any other tool, run it
		exec "${mode}" "$@"
		;;
esac
