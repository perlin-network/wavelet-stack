#! /bin/bash

syncURL="http://sync:2379/v2/keys"
peersURL="${syncURL}/peers"
mappingURL="${syncURL}/mapping"
peerID="${WAVELET_NODE_ID}"

WAVELET_API_SECRET="$(dd if=/dev/urandom bs=32 count=1 2>/dev/null | sha256sum | cut -c 1-64)"
export WAVELET_API_SECRET

function getKey() {
	local id keys

	id="$1"

	if [ -z "${id}" ]; then
		id=$["${WAVELET_NODE_ID}" - 1]
	fi

	keys="$(echo "${WAVELET_KEYS}" | cut -f $["${id}" + 1] -d ,)"
	if [ -z "${keys}" ]; then
		keys="$(awk -v id="${id}" '($1 == id) { print $2, $3; exit }' </opt/perlin/etc/wallets)"
	fi

	echo "${keys}"
}

function getPrivateKey() {
	getKey "$@" | awk '{ print $1 }'
}

function getPublicKey() {
	getKey "$@" | awk '{ print $2 }'
}

function getLocalIP() {
	getent hosts "$(uname -n)" | awk '{ print $1 }'
}

function registerPeer() {
	local ip port

	ip="$(getLocalIP)"
	port="$1"

	curl -SsL "${peersURL}/${peerID}" \
		-X PUT \
		--data value="${ip}:${port}" \
		--data ttl=30 >/dev/null 2>/dev/null
}

function maintainPeerRegistry() {
	local port
	port="$1"

	(
		while true; do
			registerPeer "${port}"
			sleep 10
		done

	) &
}

function getNodePeers() {
	local peers

	peers="$(curl -sSL http://localhost:9000/ledger 2>/dev/null | jq -crM '.peers[].address' 2>/dev/null | sort -u)"
	if [ "${peers}" = 'null' ]; then
		peers=''
	fi

	echo "${peers}"
}

function getSyncPeers() {
	local peerIDs
	local peer

	if [ "${WAVELET_NO_RPC}" = 'true' ]; then
		curl -SsL "${peersURL}" 2>/dev/null | \
			jq -crM '.node.nodes[] | select(.key | contains("/peers/'"${peerID}"'") | not) | .value' 2>/dev/null | \
			sort -u | \
			grep -v '^null$'
	else
		peerIDs=( $(curl -sSL "${peersURL}" 2>/dev/null | jq -crM '.node.nodes[].key' | sed 's@^.*/@@') )
		for peer in "${peerIDs[@]}"; do
			if [ "${peer}" = "${peerID}" ]; then
				continue
			fi

			getExternalMappingData "${peer}" | cut -f 1-2 -d / | sed 's@/@:@g'
		done | sort -u
	fi
}

function cacheExternalMappingData() {
	local data
	while true; do
		data="$(curl -sSL "${mappingURL}" 2>/dev/null | jq -crM '.node')"
		if [ "${data}" = 'null' ]; then
			data=''
		fi

		if [ -n "${data}" ]; then
			externalMappingDataCache="${data}"
			break
		fi

		sleep 0.5
	done
}

function uncacheExternalMappingData() {
	unset externalMappingDataCache
}

function getExternalMappingData() {
	local peer
	local data

	peer="$1"
	if [ -z "${peer}" ]; then
		peer="${peerID}"
	fi

	cacheExternalMappingData

	data="$(echo "${externalMappingDataCache}" | jq -crM '.nodes[] | select (.key == "/mapping/'"${peer}"'") | .value')"

	echo "${data}"

	return 0
}

function getExternalPort() {
	local port

	if [ "${WAVELET_NO_RPC}" = 'true' ]; then
		port=$[3000 + $peerID - 1]
	else
		cacheExternalMappingData

		port="$(getExternalMappingData | cut -f 2 -d /)"
	fi

	if [ -z "${port}" ]; then
		return 1
	fi

	echo "${port}"
}

function getExternalIP() {
	local addr

	if [ "${WAVELET_NO_RPC}" = 'true' ]; then
		addr="$(getLocalIP)"
	else
		cacheExternalMappingData

		addr="$(getExternalMappingData | cut -f 1 -d /)"
	fi

	if [ -z "${addr}" ]; then
		return 1
	fi

	echo "${addr}"
}

function waveletDBBackup() {
	(
		backupDir='/db/.backups'
		backupFile="${backupDir}/backup-$(date +%Y-%m-%d-%H-%M.tar.gz)"

		set -e

		mkdir -p "${backupDir}"
		cd /db

		if [ "$(echo *)" = '*' ]; then
			return
		fi

		tmpdir=''
		for try in {1..10} __fail__; do
			if [ -n "${tmpdir}" ]; then
				rm -rf "${tmpdir}"
			fi

			if [ "${try}" = '__fail__' ]; then
				exit 1
			fi

			tmpdir="$(mktemp -d)"

			(
				before="$(sha1sum * | sha1sum)"
				cp * "${tmpdir}/"
				after="$(sha1sum * | sha1sum)"

				if [ "${before}" = "${after}" ]; then
					exit 0
				else
					exit 1
				fi
			) && break
		done

		cd "${tmpdir}"

		tar -cf - * | gzip -9c > "${backupFile}"

		cd /

		rm -rf "${tmpdir}"

		cd "${backupDir}"
		find . -name 'backup-*.tar.gz' -mtime +2 -delete
	)
}

function addOrRemoveWaveletPeer() {
	local mode peer
	local curlArgs
	local output error msg

	mode="$1"
	peer="$2"

	curlArgs=(
		-H "Authorization: Bearer ${WAVELET_API_SECRET}"
		-d "{\"address\": \"${peer}\"}"
		"http://localhost:9000/node/${mode}"
	)

	output="$(curl -sSL "${curlArgs[@]}")"
	error="$(jq -crM .error <<<"${output}" 2>/dev/null)"
	msg="$(jq -crM .msg <<<"${output}" 2>/devnull)"

	if [ "${error}" = 'null' ]; then
		error=''
	fi

	if [ "${msg}" = 'null' ]; then
		msg=''
	fi

	if [ -z "${error}" -a -n "${msg}" ]; then
		return 0
	fi

	if [ -z "${msg}" -a -z "${error}" ]; then
		msg="${output}"
	fi

	if [ -z "${error}" ]; then
		error="${msg}"
	fi

	echo "Failed to ${mode} peer ${peer}: ${error}" >&2

	return 1
}

function addWaveletPeer() {
	addOrRemoveWaveletPeer connect "$@"
}

function removeWaveletPeer() {
	addOrRemoveWaveletPeer disconnect "$@"
}

function runWavelet() {
	local port
	local argNextArg
	local needPort

	port="$(getExternalPort)"
	nextArg=''
	needPort='true'
	for arg in "$@"; do
		if [ -n "${nextArg}" ]; then
			eval "${nextArg}"'=$arg'
			nextArg=''
		fi
		case "${arg}" in
			--port)
				nextArg='port'
				needPort='false'
				;;
		esac
	done

	if [ "${needPort}" = 'true' ]; then
		set -- "$@" --port "${port}"
	fi

	WAVELET_CERTS_CACHE_DIR=''
	if [ -n "${WAVELET_API_HOST}" ]; then
		WAVELET_CERTS_CACHE_DIR='/db/.certs'
		mkdir -p "${WAVELET_CERTS_CACHE_DIR}"
		chmod 700 "${WAVELET_CERTS_CACHE_DIR}"
	fi
	export WAVELET_CERTS_CACHE_DIR

	if [ -n "${WAVELET_API_ACME_ACCOUNT_KEY}" ]; then
		if [ -n "${WAVELET_CERTS_CACHE_DIR}" ]; then
			mkdir -p "${WAVELET_CERTS_CACHE_DIR}"
			echo "${WAVELET_API_ACME_ACCOUNT_KEY}" > "${WAVELET_CERTS_CACHE_DIR}/acme_account+key"
		fi
	fi

	maintainPeerRegistry "${port}"

	if [ -z "${WAVELET_MEMORY_MAX}" ] || [ "${WAVELET_MEMORY_MAX}" = '0' ]; then
		unset WAVELET_MEMORY_MAX
	fi

	if [ -z "${WAVELET_WALLET}" ]; then
		WAVELET_WALLET="$(getPrivateKey)"
	fi

	if [ -z "${WAVELET_GENESIS}" ]; then
		for ((idx = 0; idx < ${WAVELET_RICH_WALLETS}; idx++)) {
			WAVELET_GENESIS="${WAVELET_GENESIS},"'"'"$(getPublicKey "${idx}")"'": {"balance": 10000000000000000000, "rewards": 5000000}'
		}
		WAVELET_GENESIS="{${WAVELET_GENESIS:1}}"
	fi
	export WAVELET_WALLET WAVELET_GENESIS

	set | grep '^WAVELET' > /tmp/environment.txt

	haveConnectAPI='false'
	if /wavelet --help 2>/dev/null | grep 'WAVELET_API_SECRET' >/dev/null; then
		haveConnectAPI='true'
	fi

	# Add or Remove peers as they come/go
	while true; do
		sleep $[10 + ($RANDOM % 10)]

		if [ -z "${removeErrors}" ]; then
			removeErrors='0'
			addErrors='0'

			removeErrorThreshold='10'
			if [ "${haveConnectAPI}" = 'true' ]; then
				addErrorThreshold='1000'
			else
				addErrorThreshold='1'
			fi
		fi

		oldPeers=( $(getNodePeers) )
		newPeers=( $(getSyncPeers) )

		if [ "${newPeers[*]}" != "${oldPeers[*]}" ]; then
			echo "PEERS DIFFER:" >&2
			echo "  OLD: ${oldPeers[*]}" >&2
			echo "  NEW: ${newPeers[*]}" >&2

			for oldPeer in "${oldPeers[@]}"; do
				peerStillValid='false'
				for newPeer in "${newPeers[@]}"; do
					if [ "${oldPeer}" = "${newPeer}" ]; then
						peerStillValid='true'
						break
					fi
				done

				if [ "${peerStillValid}" = 'false' ]; then
					echo "  Removing: ${oldPeer}" >&2
					if removeWaveletPeer "${oldPeer}"; then
						removeErrors='0'
					else
						removeErrors=$[$removeErrors + 1]
					fi
				fi
			done
			for newPeer in "${newPeers[@]}"; do
				peerAlreadyPresent='false'
				for oldPeer in "${oldPeers[@]}"; do
					if [ "${oldPeer}" = "${newPeer}" ]; then
						peerAlreadyPresent='true'
						break
					fi
				done
				if [ "${peerAlreadyPresent}" = 'false' ]; then
					echo "  Adding: ${newPeer}" >&2
					if addWaveletPeer "${newPeer}"; then
						addErrors='0'
					else
						addErrors=$[$addErrors + 1]
					fi
				fi
			done

			# If there is a continious stream of errors coming from Wavelet
			# then kill the process and let it sort itself out
			if [ "${removeErrors}" -gt 0 -o "${addErrors}" -gt 0 ]; then
				echo "  Error Counts: Remove: ${removeErrors}/${removeErrorThreshold}; Add: ${addErrors}/${addErrorThreshold}" >&2
			fi
			if [ "${removeErrors}" -gt "${removeErrorThreshold}" -o "${addErrors}" -gt "${addErrorThreshold}" ]; then
				addErrors='0'
				removeErrors='0'
				pkill -9 -x /wavelet
			fi
		fi
	done &

	if [ "${WAVELET_BACKUP_DB}" = 'true' ]; then
		while true; do
			waveletDBBackup
			sleep $[60 * 30]
		done &
	fi

	# Run the wavelet process in a loop so that exiting just
	# causes it to reload, unless a special marker file
	# exists
	retval='1'
	waveletAddArgs=()
	while true; do
		if [ -f /tmp/wavelet.exit ]; then
			break
		fi

		if [ "${haveConnectAPI}" = 'false' ]; then
			waveletAddArgs=( $(getSyncPeers) )
		fi

		/wavelet --host "$(getExternalIP)" "$@" "${waveletAddArgs[@]}"
		retval="$?"

		sleep 0.1
	done
	exit "${retval}"
}

function runBenchmark() {
	exec /benchmark "$@" --wallet "$(getPrivateKey)"

	exit 1
}

# Start the appropriate tool
## Default to bash if no tool is specified
if [ "$#" = '0' ]; then
	set -- bash
fi

mode="$1"
shift

case "${mode}" in
	wavelet)
		runWavelet "$@"
		;;
	benchmark)
		runBenchmark "$@"
		;;
	*)
		# Any other tool, run it
		exec "${mode}" "$@"
		;;
esac
